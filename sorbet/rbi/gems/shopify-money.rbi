# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/shopify-money/all/shopify-money.rbi
#
# shopify-money-0.16.0

class MoneyParser
  def extract_amount_from_string(input, currency, strict); end
  def last_digits_decimals?(digits, marks, currency); end
  def normalize_number(number, marks, currency); end
  def parse(input, currency = nil, strict: nil); end
  def self.parse(input, currency = nil, **options); end
end
class MoneyParser::MoneyFormatError < ArgumentError
end
class Money
  def *(numeric); end
  def +(other); end
  def -(other); end
  def -@; end
  def /(numeric); end
  def <=>(other); end
  def ==(other); end
  def abs; end
  def allocate(splits, strategy = nil); end
  def allocate_max_amounts(maximums); end
  def arithmetic(money_or_numeric); end
  def as_json(*args); end
  def calculate_splits(num); end
  def calculated_currency(other); end
  def clamp(min, max); end
  def coerce(other); end
  def currency; end
  def encode_with(coder); end
  def eql?(other); end
  def floor; end
  def fraction(rate); end
  def hash(*args, &block); end
  def init_with(coder); end
  def initialize(value, currency); end
  def inspect; end
  def negative?(*args, &block); end
  def no_currency?; end
  def nonzero?(*args, &block); end
  def positive?(*args, &block); end
  def round(ndigits = nil); end
  def self.active_support_deprecator; end
  def self.current_currency; end
  def self.current_currency=(currency); end
  def self.default_currency; end
  def self.default_currency=(arg0); end
  def self.default_settings; end
  def self.deprecate(message); end
  def self.from_amount(value = nil, currency = nil); end
  def self.from_subunits(subunits, currency_iso, format: nil); end
  def self.new(value = nil, currency = nil); end
  def self.parse(*args, **kwargs); end
  def self.parser; end
  def self.parser=(arg0); end
  def self.rational(money1, money2); end
  def self.with_currency(new_currency); end
  def split(num); end
  def subunits(format: nil); end
  def to_d; end
  def to_f(*args, &block); end
  def to_i(*args, &block); end
  def to_json(options = nil); end
  def to_money(curr = nil); end
  def to_s(style = nil); end
  def value; end
  def zero?(*args, &block); end
  extend Forwardable
  include Comparable
end
module Money::Helpers
  def self.value_to_currency(currency); end
  def self.value_to_decimal(num); end
  def value_to_currency(currency); end
  def value_to_decimal(num); end
end
class Money::Currency
  def ==(other); end
  def compatible?(other); end
  def decimal_mark; end
  def disambiguate_symbol; end
  def eql?(other); end
  def hash; end
  def initialize(currency_iso); end
  def iso_code; end
  def iso_numeric; end
  def minor_units; end
  def name; end
  def self.currencies; end
  def self.find!(currency_iso); end
  def self.find(currency_iso); end
  def self.new(currency_iso); end
  def smallest_denomination; end
  def subunit_symbol; end
  def subunit_to_unit; end
  def symbol; end
  def to_s; end
end
module Money::Currency::Loader
  def self.deep_deduplicate!(data); end
  def self.load_currencies; end
end
class Money::Currency::UnknownCurrency < ArgumentError
end
class Money::NullCurrency
  def ==(other); end
  def compatible?(other); end
  def decimal_mark; end
  def disambiguate_symbol; end
  def eql?(other); end
  def initialize; end
  def iso_code; end
  def iso_numeric; end
  def minor_units; end
  def name; end
  def smallest_denomination; end
  def subunit_symbol; end
  def subunit_to_unit; end
  def symbol; end
  def to_s; end
end
class Money::Allocator < SimpleDelegator
  def all_rational?(splits); end
  def allocate(splits, strategy = nil); end
  def allocate_max_amounts(maximums); end
  def allocation_index_for(strategy, length, idx); end
  def amounts_from_splits(allocations, splits, subunits_to_split = nil); end
  def extract_currency(money_array); end
  def initialize(money); end
end
class Money::ReverseOperationProxy
  def *(other); end
  def +(other); end
  def -(other); end
  def <=>(other); end
  def initialize(value); end
  include Comparable
end
class Money::Error < StandardError
end
class Money::IncompatibleCurrencyError < Money::Error
end
class AccountingMoneyParser < MoneyParser
  def parse(input, currency = nil, **options); end
end
class Numeric
  def to_money(currency = nil); end
end
class String
  def to_money(currency = nil); end
end
